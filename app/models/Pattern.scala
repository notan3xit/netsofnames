package models

import play.api.Play.current
import anorm._
import anorm.SqlParser._
import play.api.db.DB
import play.Logger
import scala.util.matching.Regex
import java.util.regex.Matcher
import util.LanguageProcessing
import controllers.Application

/**
 * Object representation of a pattern.
 * 
 * @param id The id (and primary key) of the pattern.
 * @param rule The generalized lexico-syntatctic pattern.
 * @param label The generalized label.
 * @param tagId The tag this pattern was created from.
 * @param timesApplied The number of times this pattern was applied.
 * @param positiveVotes The number of applications accepted by users.
 * @param negativeVotes The number of applications rejected by users.
 * @param disabled Whether or not this pattern is currently active.
 */
case class Pattern(id: Pk[Long] = NotAssigned, rule: String, label: String, tagId: Long,
    timesApplied: Long = 0, positiveVotes: Long = 0, negativeVotes: Long = 0, disabled: Boolean = false) {
  
  import util.UpString._
  
  /**
   * Pattern precision, given by the fraction of accepted application in all validated applications.
   */
  def performance = if (timesApplied == 0) 0d else (positiveVotes).toDouble / (positiveVotes + negativeVotes)
  
  /**
   * The coverage of validations, i.e. the fraction of validated instances of all applications.
   */
  def coverage = if (timesApplied == 0) 0d else (positiveVotes + negativeVotes).toDouble / timesApplied
  
  /**
   * All tags that were generated using this pattern.
   */
  lazy val tags = Tag.byPattern(id.get)
  
  /**
   * Whether or not this pattern contains a keyword.
   */
  lazy val hasKeyword = {
    rule.contains("<WORD>")
  }
  
  /**
   * Returns entity types (PERSON, ORGANIZATION) and semantic roles ("S", "O") encoded in the rule.
   */
  lazy val (firstType, firstRole, secondType, secondRole) = {
    val results = "<(PERSON|ORGANIZATION)/(.+?)>".r.findAllMatchIn(rule).toList
    (results(0).group(1), results(0).group(2), results(1).group(1), results(1).group(2))
  }
  
  /**
   * Given two entity names, creates a regular expression that matches occurrences of this pattern with
   * the given names.
   */
  def regex(firstName: String, secondName: String) = {
    val p = """\Q""" + rule
      .replaceAll("<WORD>", """\\E([\\p{L}-]+)\\Q""")
      .replaceFirst("<%s/%s>".format(firstType, firstRole), firstName)
      .replaceFirst("<%s/[SO]>".format(secondType), secondName) + """\E"""
    new Regex(p, "keyword")
  }
  
  /**
   * Creates a wildcard-pattern for SQL queries by replacing all variable parts by '%', the SQL
   * expression for 'any string'.
   * 
   * Can be used in queries like "... WHERE sentence LIKE 'SQL_PATTERN'".
   */
  val sqlPattern = "%" +
    (rule
      .replaceAll("""<WORD>""", "%")
      .replaceAll("""<(PERSON|ORGANIZATION)/(.+?)>""", "%")) +
    "%"
  
  def hasPerson() = {
    firstType == "PERSON" || secondType == "PERSON"
  }
  
  def hasOrganization() = {
    firstType == "ORGANIZATION" || secondType == "ORGANIZATION"
  }
  
  /**
   * Given a <tt>sentence</tt> and a <tt>relationship</tt>, attempts to apply this pattern. Returns a list of tags that
   * are generated by the application (can be an empty list if pattern cannot be applied).
   */
  def apply(sentence: Sentence, relationship: Relationship) = {
    // get entities from relationships
    val e1 = relationship.entity1
    val e2 = relationship.entity2
    
    // create feasible permutation of entity order, given the types encoded in the rule
    List(
      if (e1.typeString == firstType && e2.typeString == secondType) Some(e1, e2) else None,
      if (e2.typeString == firstType && e1.typeString == secondType) Some(e2, e1) else None
    ).flatten flatMap { case (first, second) =>
      // find matches of rule instances in the sentence
      regex(first.name, second.name).findFirstMatchIn(sentence.text)
        // if this is a keyword pattern, check the replacement for the keyword is not a stopword
        .filter { m => m.groupCount == 0 || !LanguageProcessing.isStopword(m.group("keyword")) }
        // create tags from matches
        .map { m =>
          // determine direction
          val direction = (if (e1 == first) (firstRole, secondRole) else (secondRole, firstRole)) match {
            case ("S", "O") => Tag.Right
            case ("O", "S") => Tag.Left
            case ("S", "S") => Tag.Both
            case _ => throw new RuntimeException("This should never happen.")
          }
          
          // replace found keyword into the label
          val assignedLabel = if (m.groupCount > 0) {
            label.replace("<WORD>", m.group("keyword"))
          } else label
          
          // construct tag
          new Tag(NotAssigned, relationship.id.get, sentence.id, assignedLabel, direction = direction, automatic = true)
        }
    }
  }
  
  def withValues(id: Pk[Long] = this.id, rule: String = this.rule, label: String = this.label, tagId: Long = this.tagId,
      timesApplied:  Long = this.timesApplied, positiveVotes:  Long = this.positiveVotes, negativeVotes: Long = this.negativeVotes, disabled: Boolean = this.disabled) = {
    new Pattern(id, rule, label, tagId, timesApplied, positiveVotes, negativeVotes, disabled)
  }
}

/**
 * Companion object and DAO for patterns.
 */
object Pattern {
  
  /**
   * Simple parser for pattern result sets (with empty measures).
   */
  val simple = {
    get[Pk[Long]]("id")~
    get[String]("rule")~
    get[String]("label")~
    get[Long]("original_tag")~
    get[Boolean]("disabled") map {
      case id~rule~label~tag~disabled =>
        new Pattern(id, rule, label, tag, 0, 0, 0, disabled)
    }
  }
  
  /**
   * Result set parser for patterns (including measures).
   */
  val withMeasures = {
    get[Pk[Long]]("id")~
    get[String]("rule")~
    get[String]("label")~
    get[Long]("original_tag")~
    get[Option[Long]]("applied")~
    get[Option[Long]]("positive")~
    get[Option[Long]]("negative")~
    get[Boolean]("disabled") map {
      case id~rule~label~tag~applied~positive~negative~disabled =>
        new Pattern(id, rule, label, tag, applied.getOrElse(0), positive.getOrElse(0), negative.getOrElse(0), disabled)
    }
  }
  
  /**
   * Creates the pattern if a pattern with this rule does not already exists. Returns the new pattern
   * (with the generated primary key) or the existing pattern.
   * 
   * TODO In fact, patterns can have more differences than just the rule. Specifically, this is the case for different
   * labels and tag directions.
   */
  def create(pattern: Pattern, tagId: Long) = {
    DB.withTransaction { implicit connection =>
      // check whether a pattern with this rule already exists
      val existing = SQL("""
        SELECT *
        FROM   patterns
        WHERE  rule = {rule}
      """).on(
        'rule -> pattern.rule
      ).as(simple.singleOpt)
      
      // return existing pattern or create a new one
      existing getOrElse {
        // create pattern
        val id = SQL("""
          INSERT INTO patterns
            (rule, label, original_tag)
          VALUES
            ({rule}, {label}, {tId})
        """).on(
          'rule -> pattern.rule,
          'label -> pattern.label,
          'tId -> pattern.tagId
        ).executeInsert()
        
        // create initial link to tag, so that immediate confirmation/removal actions by the user have semantics
        SQL("""
          INSERT INTO patterns_to_tags
            (pattern_id, tag_id, positive, negative)
          VALUES
            ({pId}, {tId}, 1, 0)
        """).on(
          'pId -> id,
          'tId -> tagId
        ).execute()
        
        pattern.withValues(id = Id(id.get))
      }
    }
  }
  
  def castPositiveVote(tagId: Long) = {
    DB.withConnection { implicit connection =>
      SQL("""
        UPDATE patterns_to_tags
        SET    positive = 1
        WHERE  tag_id = {tId}
      """).on(
        'tId -> tagId
      ).executeUpdate()
    }
  }
  
  def castNegativeVote(tagId: Long) = {
    DB.withConnection { implicit connection =>
      SQL("""
        UPDATE patterns_to_tags
        SET    negative = 1
        WHERE  tag_id = {tId}
      """).on(
        'tId -> tagId
      ).executeUpdate()
    }
  }
  
  def byId(id: Long) = {
    DB.withConnection { implicit connection =>
      SQL("""
        SELECT
          p.id AS id,
          p.rule AS rule,
          p.label AS label,
          p.original_tag AS original_tag,
          count(p2t.*) AS applied,
          sum(p2t.positive) AS positive,
          sum(p2t.negative) AS negative,
          sum(p2t.positive) / NULLIF(sum(p2t.positive) + sum(p2t.negative), 0) AS performance,
          p.disabled AS disabled
        FROM patterns p
        LEFT JOIN patterns_to_tags p2t ON p2t.pattern_id = p.id
        WHERE id = {id}
        GROUP BY id
      """).on(
        'id -> id
      ).as(withMeasures.singleOpt)
    }
  }
  
  def byTag(tag: Tag) = {
    DB.withConnection { implicit connection =>
      SQL("""
        SELECT
          p.id AS id,
          p.rule AS rule,
          p.label AS label,
          p.original_tag AS original_tag,
          count(p2t.*) AS applied,
          sum(p2t.positive) AS positive,
          sum(p2t.negative) AS negative,
          (sum(p2t.positive) - sum(p2t.negative)) / NULLIF(count(p2t.*), 0) AS performance,
          p.disabled AS disabled
		FROM patterns_to_tags p2t
        JOIN patterns p ON p.id = p2t.pattern_id
        WHERE p2t.tag_id = {tId}
        GROUP BY id
      """).on(
        'tId -> tag.id
      ).as(withMeasures.*)
    }
  }
  
  def disable(pattern: Pattern) = {
    DB.withTransaction { implicit connection =>
      SQL("""UPDATE patterns SET disabled = true WHERE id = {id}""")
        .on('id -> pattern.id)
        .execute()
      
      SQL("""
        DELETE FROM tags
        WHERE auto = true
        AND id IN (SELECT tag_id FROM patterns_to_tags WHERE pattern_id = {id})
      """).on(
        'id -> pattern.id
      ).execute()   
    }
    pattern.withValues(disabled = true)
  }
  
  def enable(pattern: Pattern) = {
    DB.withConnection { implicit connection =>
      SQL("""UPDATE patterns SET disabled = false WHERE id = {id}""")
        .on('id -> pattern.id)
        .execute()
    }
    pattern.withValues(disabled = false)
  }
}